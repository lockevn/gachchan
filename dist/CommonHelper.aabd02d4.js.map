{"mappings":"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","sources":["src/helper/CommonHelper.ts"],"sourcesContent":["﻿import _flatten from 'lodash/flatten.js'\r\nimport _isNumber from 'lodash/isNumber.js'\r\nimport _isFinite from 'lodash/isFinite.js'\r\nimport _intersectionWith from 'lodash/intersectionWith.js'\r\nimport _intersection from 'lodash/intersection.js'\r\n\r\nimport Decimal from 'decimal.js'\r\nimport { DateTimeHelper } from './DateTimeHelper'\r\n\r\nexport class CommonHelper {\r\n  /**\r\n   * if provide a number or number-string, this will return a number, with fractationDigits\r\n   * if provided a string (\"AT, ATC, ATO\") throw exception\r\n   * NonNumberValue like null, undefined and NaN is treat as 0\r\n   * @param {string} numberString\r\n   * @param {number} fractationDigits number of decimal digit\r\n   * @returns number\r\n   */\r\n  static ToNumber(numberString: number | string, fractationDigits: number = 2, treatNonNumberValueAs = 0) {\r\n    let ret = treatNonNumberValueAs\r\n\r\n    const convertedToNumberVal = +numberString\r\n    // note that isNumber(NaN) == true\r\n    if (_isNumber(convertedToNumberVal) && !isNaN(convertedToNumberVal)) {\r\n      ret = convertedToNumberVal\r\n    }\r\n\r\n    if (fractationDigits !== undefined) {\r\n      ret = new Decimal(ret).toDP(fractationDigits).toNumber()\r\n    }\r\n\r\n    return ret\r\n  }\r\n\r\n  /**\r\n   * round value to X decimal places https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary\r\n   * 19.103857566765578635.toBe(19.1)\r\n   * 19.143857566765578635.toBe(19.1)\r\n   * 19.144857566765578635.toBe(19.1)\r\n   * @param {*} value\r\n   * @returns\r\n   */\r\n  static RoundNumber(value: number, decimalPlaces = 1) {\r\n    const decimalPlacesMultiplier = Math.pow(10, decimalPlaces)\r\n    return Math.round((value + Number.EPSILON) * decimalPlacesMultiplier) / decimalPlacesMultiplier\r\n  }\r\n\r\n  /**\r\n   * Continuously call actionFn by setTimeout with interval. The next process will be schedule after current process completed (success or failed)\r\n   * Interval can be determined (randomly) by intervalFn() and delay between execution can be vary.\r\n   * @param actionFn support async function\r\n   * @param DEFAULT_INTERVAL if nothing provided or callbackFn success, this is the interval for running. If adjustment happen, it will not exceed 2*DEFAULT_INTERVAL\r\n   * @param intervalFn intervalFn(currentDelay, isPreviousRunSuccess, DEFAULT_INTERVAL). if currentDelay is undefined, should return the default. if currentDelay has value, should return next delay.\r\n   * @param executeImmediately default = false. If true, invoke actionFn() immediately (in the beginning) when calling this function\r\n   * @param shouldPerformActionFn shouldPerformActionFn(currentDelay, isPreviousRunSuccess, DEFAULT_INTERVAL). this function should return true if you want to perform actionFn when timeout happen.\r\n   */\r\n  static async ContinuousExecuteBySetTimeout(\r\n    actionFn: Function,\r\n    DEFAULT_INTERVAL: number = 10000,\r\n    intervalFn?: (previousDelay: number, isPreviousRunSuccess: boolean, DEFAULT_INTERVAL: number) => number,\r\n    executeImmediately = false,\r\n    shouldPerformActionFn = (_0: number, _1?: boolean, _2?: number) => true\r\n  ): Promise<{\r\n    timerId: any\r\n    delay: number\r\n  }> {\r\n    let ret = {\r\n      timerId: undefined as any,\r\n      delay: NaN,\r\n    }\r\n\r\n    if (!actionFn || typeof actionFn != 'function') {\r\n      return ret\r\n    }\r\n\r\n    // use the default intervalFn\r\n    if (typeof intervalFn != 'function') {\r\n      intervalFn = CommonHelper.ContinuousExecuteBySetTimeoutDefaultIntervalFn\r\n    }\r\n\r\n    let delay = intervalFn(DEFAULT_INTERVAL, true, DEFAULT_INTERVAL)\r\n    let isPreviousRunSuccess: boolean | undefined = undefined\r\n\r\n    async function run() {\r\n      try {\r\n        if (shouldPerformActionFn(delay, isPreviousRunSuccess, DEFAULT_INTERVAL)) {\r\n          await actionFn()\r\n          isPreviousRunSuccess = true\r\n        }\r\n      } catch (error) {\r\n        isPreviousRunSuccess = false\r\n      }\r\n\r\n      // calculate the new delay for the next run\r\n      delay = intervalFn?.(delay, isPreviousRunSuccess || false, DEFAULT_INTERVAL) || DEFAULT_INTERVAL\r\n      ret.delay = delay\r\n      ret.timerId = setTimeout(run, delay)\r\n      // console.debug(`${ret.delay} ${ret.timerId} after setTimeout`)\r\n    }\r\n\r\n    // run immediately when being called, not after wait for the first timeout\r\n    if (executeImmediately && shouldPerformActionFn(delay, isPreviousRunSuccess, DEFAULT_INTERVAL)) {\r\n      try {\r\n        await actionFn()\r\n        isPreviousRunSuccess = true\r\n      } catch (error) {\r\n        isPreviousRunSuccess = false\r\n      }\r\n    }\r\n    ret.timerId = setTimeout(run, delay)\r\n    // console.debug(`${ret.delay} ${ret.timerId} after setTimeout -------- INIT`)\r\n\r\n    return ret\r\n  }\r\n\r\n  /**\r\n   * Create a default delay number (calculate delay based on previous delay and isPreviousRunSuccess).\r\n   * When calling ContinuousExecuteBySetTimeout() without intervalFn, this func will be used as default implementation.\r\n   * PreviousRunSuccess ==> return DEFAULT_INTERVAL.\r\n   * PreviousRunFailed ==> return random * (1.2 to 2.0) * DEFAULT_INTERVAL.\r\n   * @param {*} previousDelay\r\n   * @param {*} isPreviousRunSuccess\r\n   * @returns\r\n   */\r\n  static ContinuousExecuteBySetTimeoutDefaultIntervalFn(previousDelay: number, isPreviousRunSuccess: boolean, DEFAULT_INTERVAL: number): number {\r\n    if (isPreviousRunSuccess) {\r\n      return DEFAULT_INTERVAL // job is done successfully, we back to use DEFAULT_INTERVAL (because prev delay (which is a failed one) can be (e.g. 12345ms), longer than DEFAULT_INTERVAL)\r\n    }\r\n\r\n    // adjust delay to be longer than previousDelay, but maximum is 2 * DEFAULT_INTERVAL\r\n    let newDelay = previousDelay || DEFAULT_INTERVAL\r\n    // increase delay, at least 20%\r\n    newDelay = Math.round(newDelay * (1.2 + Math.random()))\r\n    if (newDelay > 2 * DEFAULT_INTERVAL) {\r\n      newDelay = 2 * DEFAULT_INTERVAL\r\n    }\r\n    // console.debug(\"change to different newDelay for next request:\", newDelay)\r\n\r\n    return newDelay\r\n  }\r\n\r\n  /** change 1 to 1️⃣ (unicode square box character) */\r\n  static RepresentNumberInIconicDigit(numberString: string | null | undefined): string {\r\n    if (!numberString) {\r\n      return ''\r\n    }\r\n\r\n    let ret = numberString.toString()\r\n    ret = ret\r\n      .replace(/0/g, '0️⃣')\r\n      .replace(/1/g, '1️⃣')\r\n      .replace(/2/g, '2️⃣')\r\n      .replace(/3/g, '3️⃣')\r\n      .replace(/4/g, '4️⃣')\r\n      .replace(/5/g, '5️⃣')\r\n      .replace(/6/g, '6️⃣')\r\n      .replace(/7/g, '7️⃣')\r\n      .replace(/8/g, '8️⃣')\r\n      .replace(/9/g, '9️⃣')\r\n\r\n    return ret\r\n  }\r\n\r\n  /**\r\n   * random an integer. Max = 10, so return 0 to 10\r\n   * @param max the maximum number this func can return\r\n   * @returns number integer\r\n   */\r\n  static GetRandomIntegerTo(max: number) {\r\n    return this.GetRandomIntegerFromTo(0, max)\r\n  }\r\n\r\n  /**\r\n   * random an integer, return value from min to max. (0,10) ==> return any integer from 0 to 10\r\n   * @returns number integer\r\n   */\r\n  static GetRandomIntegerFromTo(min: number, max: number): number {\r\n    const range = max - min + 1\r\n    return Math.floor(Math.random() * range) + min\r\n  }\r\n\r\n  /**\r\n   * return random element inside array\r\n   * @param {*} arr\r\n   * @returns\r\n   */\r\n  static GetRandomArrayElement(arr: any[]) {\r\n    if (Array.isArray(arr)) {\r\n      return arr[CommonHelper.GetRandomIntegerTo(arr.length - 1)]\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This will modify the input array https://stackoverflow.com/a/2450976\r\n   * @param {*} array\r\n   * @returns\r\n   */\r\n  static ShuffleArray(array: any[]) {\r\n    let currentIndex = array.length,\r\n      randomIndex\r\n\r\n    // While there remain elements to shuffle.\r\n    while (currentIndex != 0) {\r\n      // Pick a remaining element.\r\n      randomIndex = Math.floor(Math.random() * currentIndex)\r\n      currentIndex--\r\n\r\n      // And swap it with the current element.\r\n      ;[array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]]\r\n    }\r\n\r\n    return array\r\n  }\r\n\r\n  /**\r\n   * check for intersection of number or string\r\n   * E.g.: [1,2,3], 2 ==> true\r\n   * E.g.: [\"a\",\"b\",\"c\"], [\"a\"] ==> true\r\n   * E.g.: [\"a\",\"b\",\"c\"], [\"A\"], true ==> true, a==A because of ignoreCase\r\n   *\r\n   * value (which is not string) is compared by === (null === null, undefined === undefined)\r\n   * @param firstList\r\n   * @param otherList accept single value or array\r\n   * @param ignoreCase if any value is string, cast either values of firstList and otherList toString(), then compare ignore case\r\n   * @returns boolean true if there is an intersection\r\n   */\r\n  static HasAnyOfIntersection(firstList: number | string | (number | string)[], otherList: number | string | (number | string)[] = '', ignoreCase = true) {\r\n    if (!firstList || !otherList) return false\r\n\r\n    const arrFirsts = _flatten([firstList]) // [\"\"]   ==> [\"\"], [[1,2]]   ==> [1,2]\r\n    const arrEvaluations = _flatten([otherList]) // [\"\"]   ==> [\"\"], [[1,2]]   ==> [1,2]\r\n\r\n    let ret\r\n    if (ignoreCase) {\r\n      ret =\r\n        _intersectionWith(arrFirsts, arrEvaluations, (listVal, otherVal) => {\r\n          if (typeof listVal === 'string' || typeof otherVal === 'string') {\r\n            return listVal?.toString()?.toUpperCase() === otherVal?.toString()?.toUpperCase()\r\n          }\r\n\r\n          return listVal === otherVal\r\n        }).length > 0\r\n    } else {\r\n      ret = _intersection(arrFirsts, arrEvaluations).length > 0\r\n    }\r\n    return ret\r\n  }\r\n\r\n  /**\r\n   * return percent of portion to full, (25, 50) ==> 50\r\n   */\r\n  static Percent(portion: number, full: number, fractationDigits?: number) {\r\n    let ret = (100 * portion) / full\r\n    return CommonHelper.ToNumber(ret, fractationDigits)\r\n  }\r\n\r\n  /**\r\n   * from 100 to 110, the diff is 10 (is 10%). This function returns 10\r\n   * @returns null if from to is not number\r\n   */\r\n  static DiffInPercent(from: number, to: number, fractationDigits?: number) {\r\n    let ret = null\r\n\r\n    if (_isFinite(from) && _isFinite(to)) {\r\n      ret = CommonHelper.Percent(to - from, from, fractationDigits)\r\n    }\r\n\r\n    return ret\r\n  }\r\n\r\n  // =========== ===================== ===========\r\n  // =========== string representation ===========\r\n  // =========== ===================== ===========\r\n\r\n  /**\r\n   * join all arguments with \"/\" seperator.\r\n   * E.g.: JoinPaths(\"a\", b, c)\r\n   */\r\n  static JoinPaths(...parts: (string | number | null | undefined)[]) {\r\n    var separator = '/'\r\n    var replace = new RegExp(separator + '{1,}', 'g') // replace multiple to single separator\r\n    return parts\r\n      .filter((p) => p)\r\n      .join(separator)\r\n      .replace(replace, separator)\r\n  }\r\n\r\n  // =========== ===================== ===========\r\n  // =========== string representation ===========\r\n  // =========== ===================== ===========\r\n\r\n  /**\r\n   * empty string, null, NaN, undefined return \"\"\r\n   *  or text string which is not a number, return \"\"\r\n   * format number to string (usage of PercentValueFormatter can use this)\r\n   * @param val\r\n   * @param fractationDigits\r\n   * @param showPrefixSign\r\n   * @param showZeroVal\r\n   * @param suffix\r\n   * @returns\r\n   */\r\n  static ToNumberString(val?: number | string, fractationDigits = 2, showPrefixSign = false, showZeroVal = true, suffix = '') {\r\n    if (val == 0 && !showZeroVal) {\r\n      return ''\r\n    }\r\n\r\n    if (!val && val !== 0) {\r\n      // NaN, undefined, null, \"\"\r\n      return ''\r\n    }\r\n\r\n    const prefixSign = showPrefixSign && +val > 0 ? '+' : ''\r\n    return prefixSign + CommonHelper.ToNumber(val, fractationDigits) + suffix\r\n  }\r\n\r\n  /**\r\n   * display 1000000 as 1tr, 1000 as 1k\r\n   * display 1000000 as 1,000,000 (when using en-US locale)\r\n   * Also round the number after converting (100400 ==> 100k, 100500 ==> 101k)\r\n   * vi-VN default thounsand separator is ,\r\n   * 0 will be returned as \"0\"\r\n   * NaN or \"\" will be returned as \"\"\r\n   * \"ATC\" (which is cannot be converted to number) will be returned as is \"ATC\"\r\n   * @param {number | string} numberString original number (string) to format. This string must be able to convert to number.\r\n   * @param {number} unitDividen dividen divide number to this\r\n   * @param {number} fractationDigits default is 0 (1000 --> 1,000). if 1, 1000,1 --> 1,000.1\r\n   * @param {string} unit default is \"tr\" (triệu đồng VN)\r\n   * @param {string} locale \"en-US\" \"vi-VN\"\r\n   */\r\n  static NumberToUnitString(numberString: number | string, unitDividen = 1, fractationDigits = 0, unit = '', locale = 'en-US'): string {\r\n    // empty string, or text string which is not a number, return\r\n    if (numberString === 0) return '0'\r\n    if (!numberString) return ''\r\n    if (!+numberString) return numberString?.toString()\r\n\r\n    let unitNumbers = (+numberString / unitDividen).toFixed(fractationDigits)\r\n    return new Intl.NumberFormat(locale).format(+unitNumbers) + unit\r\n  }\r\n\r\n  // @deprecated\r\n\r\n  /**\r\n   * @deprecated since version 6.1.0\r\n   * if now is 2002 12 31 14:22, this return 20021231.\r\n   * @param {Date} date\r\n   * @returns {string}\r\n   */\r\n  static GetCurrentYearMonthDayString = DateTimeHelper.GetCurrentYearMonthDayString\r\n\r\n  /**\r\n   * @deprecated since version 6.1.0\r\n   * if now is 14:22, this return 1422.\r\n   * 9:40AM ==> 0940\r\n   * 16:03 (PM) ==> 1603\r\n   * @param {Date} date\r\n   * @returns {string}\r\n   */\r\n  static GetCurrentHoursMinutesString = DateTimeHelper.GetCurrentHoursMinutesString\r\n\r\n  /**\r\n   * @deprecated since version 6.1.0\r\n   * if now is 14:22:59, this return 142259.\r\n   * 9:40AM ==> 094000\r\n   * 16:03 (PM) ==> 160300\r\n   */\r\n  static GetCurrentHoursMinutesSecondsString = DateTimeHelper.GetCurrentHoursMinutesSecondsString\r\n\r\n  /**\r\n   * @deprecated since version 6.1.0\r\n   * @returns string the Date string in format yyyyMMdd (in UTC timezone)\r\n   */\r\n  static GetCurrentYearMonthDayStringUTC = DateTimeHelper.GetCurrentYearMonthDayStringUTC\r\n\r\n  /**\r\n   * @deprecated since version 6.1.0\r\n   * @returns string the Time string in format HHmm (in UTC timezone)\r\n   */\r\n  static GetCurrentHoursMinutesStringUTC = DateTimeHelper.GetCurrentHoursMinutesStringUTC\r\n\r\n  /**\r\n   * @deprecated since version 6.1.0\r\n   * @returns string the Time string in format HHmmss (in UTC timezone)\r\n   */\r\n  static GetCurrentHoursMinutesSecondsStringUTC = DateTimeHelper.GetCurrentHoursMinutesSecondsStringUTC\r\n\r\n  /**\r\n   * @deprecated since version 6.1.0\r\n   * return current date time in full format, in specific culture (language) and timezone\r\n   * @param {*} culture\r\n   * @param {*} timezone\r\n   * @returns\r\n   */\r\n  static GetDatetimeNowString = DateTimeHelper.GetDatetimeNowString\r\n}\r\n"],"names":[],"version":3,"file":"CommonHelper.aabd02d4.js.map"}